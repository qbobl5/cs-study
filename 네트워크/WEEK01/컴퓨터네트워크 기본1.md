<img width="634" alt="스크린샷 2025-03-24 오후 4 46 42" src="https://github.com/user-attachments/assets/2c104923-3697-42c6-afda-f38b6cfb0eae" />

## 📌 네트워크 엣지
<img width="338" alt="스크린샷 2025-03-24 오후 4 47 55" src="https://github.com/user-attachments/assets/560ae9e3-064e-4e6c-b300-df7c7f78a22d" />

> 가장자리라고 볼 수 있음. (<-> 네트워크 코어)

> 우리가 쓰는 컴퓨터, 웹 어플리케이션, 웹 서버 등은 다 네트워크 엣지
### ✅ 종류
- 클라이언트
  - 원할때 링크에 연결해서 서버로부터 정보를 받아옴
- 서버
  - 24시간 항시 연결중임. 클라이언트의 요청 대기중
### ✅ 데이터 전달 방식
- TCP
  > 너한테 맞춰줄게
  - `reliable` `in-order` 순차적으로 똑같이 전달
  - `flow control` sender가 보내는 속도를 조절해줌. 리시버가 받을 수 있는 능력에 맞춰서
  - `congestion control` 네트워크 상황에 맞춰 받아들일 수 있도록
  - 우리가 사용하는 웹 브라우저
- UDP
  > 내맘대로 보낼게
  - `connectionless` `unreliable` `no flow control` `no congestion control`
  - 전화나 영상 등에 활용 > 패킷 유실이 좀 발생하더라도 크게 문제가 안 된다.
- 그래도 TCP가 훨씬 좋아보이는데 UDP를 쓰는 이유는?
  > TCP는 좋은만큼 비용이 더 비싸다. 그러므로 100% 정확한 패킷 전달이 필요한 상황이 아니면 UDP를 쓰는 것이다.
- 프로토콜

  <img width="673" alt="스크린샷 2025-03-24 오후 4 48 22" src="https://github.com/user-attachments/assets/b3bb2d9d-5548-4265-af1e-52818dac1fa1" />

  > TC**P** & UD**P** 모두 P가 들어간다. 왜? 프로토콜이므로.
  - 중요한 메시지를 받기 위한 준비동작이라고 볼 수 있음
  - `ex`
    - 어디에 있는지가 중요한 상황: Hi -> Hi -> Where are you? -> **Hospital**
    - 전송가능? -> 전송가능! -> **데이터 전송**
  - 즉, 프로토콜이 안 맞으면 얘기가 안 통함.

<br>

## 📌 네트워크 코어
<img width="321" alt="스크린샷 2025-03-24 오후 4 48 56" src="https://github.com/user-attachments/assets/5921bb32-70ee-4b2c-a7ac-433faaa27a96" />

> 네트워크의 중심
### ✅ 라우터
- 네트워크의 중심에 있는 대표적인 네트워크 코어
### ✅ 데이터 전달 방식
- Circuit Switching
  - 길 예약 > 특정 사용자를 위한
  - 예전 유선전화망
- Packet Switching
  - 그때그때 forwarding
  - 패킷 받아서 들어오는대로 보내준다
  - 인터넷
- C.S vs P.S
  - `Question` 1Mbps (초당 1mb) 인 라우터에 N명의 사용자들이 데이터 전달을 시도한다. 이때 두 가지 방식의 차이는?
    - Circuit : 100kb씩 10명이 사용 가능
    - Packet : 제한 X
      - 근데 안 터져? 라는 의문 > 예를 들어 35명이 사용한다고 치자. 보통 35명이 동시에 사용하지 않고, 각자 필요할때 사용함.
      - A라는 사람이 사용함 -> X -> X -> -> 사용함 -> X -> X -> X -> 사용함 이런식의 흐름으로 사용한다고 하면? 35명이 동시에 저렇게 사용하지 않는 한 터지지 않음.
      - 이때, Circuit은 저런 X 인 곳에서 낭비가 되는 것임.
      - *BUT!!* 수강신청, 티켓팅 등의 상황에서는 문제가 발생할 수가 있다! < 동시에 사용하니까

 <br>

## 📌 패킷 스위칭의 문제점
> delay
### ✅ Nodal Processing
- `패킷 -> 라우터 -> 다음 라우터` 여기서 라우터가 패킷검사를 하고 목적지가 어디인지 등 필수 작업을 필요로 한다.
- 이때 생기는 delay
### ✅ Queueing
- `패킷 (속도 500) -> 라우더 (속도 100) -> 다음 라우터` 여기서 패킷이 보내는 속도가 더 빠르면? 다 터지고 유실된다.
- 즉, 저장소 필요! `ex` Buffer, Queue
- 이때 Queue에 들어가서 기다리는 delay
### ✅ Transmission
- Queue의 맨 앞에 도착하여 다음 라우터로 나가야지~ 하는 상황
- 이때 1번째 bit부터 마지막 bit까지 내뿜는 동안의 시간이 delay
- 예를 들어 패킷(물)이라고 가정하고 지름이 1cm인 파이프와 10cm인 파이프 둘다에 부었을때 어디가 더 빨리 나가느냐? 당연히 10cm 짜리 파이프이다.
- 즉, 이런식으로 delay 영향이 생긴다.
### ✅ Propagation
- 마지막 bit가 다음 라우터에 도달하는 시간
- 비트가 가는 시간은 빛의 속도이므로, 링크의 길이를 빛의 속도로 나눈 값이 delay
### 💡 delay를 줄여보자!
- processing delay
  - 성능이 좋은 라우터를 쓰면 해결
- Transmission delay
  - 케이블이 좋으면 됨
- Queueing delay
  - 제일 골치가 아프다.
  - Queue가 꽉차면 > 패킷이 유실된다. = `Packet Loss`
  - 즉, 유실의 90%는 큐에서 발생!
  - 여기서 문제! TCP는 그럼 어떻게 해? 유실이 되면 안되는 전달 방식이기 때문
    > `A -> x -> x -> x -> B` (x 는 라우터)
    
    3번째 라우터에서 유실되었다면? TCP는 100% 패킷 전송을 해야하므로 다시 전송해야한다.

    그럼 A에서부터 다시 전송할까? OR 직전 라우터가 다시 전송할까? > 답은 A에서부터!

    - 인터넷은 A, B만 브레인으로 사용한다. 라우터는 할 일이 많기때문.
    - 그래서 라우터가 다른 일을 하면 효율이 떨어지고 속도가 너무 늘어나므로 A에서 다시 전송하는 방식 채택
